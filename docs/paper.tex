\documentclass[conference]{IEEEtran}
\IEEEoverridecommandlockouts
\usepackage{cite}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage{algorithmic}
\usepackage{graphicx}
\usepackage{textcomp}
\usepackage{xcolor}
\usepackage{kotex}
\usepackage{multirow}
\usepackage{booktabs}
\usepackage{array}
\usepackage{url}

\def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08em
    T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}

\begin{document}

\title{GDP(Generative Digital-twin Prototyper): LLM 기반 공정 설계 자동화 및 분석 도구 연동 프레임워크}

\author{\IEEEauthorblockN{이건창}
\IEEEauthorblockA{\textit{DMC공학과} \\
\textit{성균관대학교}\\
수원, 대한민국 \\
email@skku.edu}
\and
\IEEEauthorblockN{홍길동\textsuperscript{*}}
\IEEEauthorblockA{\textit{DMC공학과} \\
\textit{성균관대학교}\\
수원, 대한민국 \\
hwoo@skku.edu}
}

\maketitle

\begin{abstract}
스마트 인더스트리(Smart Industry)의 핵심 기술인 디지털 트윈(Digital Twin)을 성공적으로 구현하기 위해서는 정교한 제조 데이터 확보와 이를 활용한 시뮬레이션 체계가 필수적이다. 그러나 실제 산업 데이터는 외부 연구자가 접근하기 어렵고 파편화되어 있으며, 설계 정보를 분석 도구로 연결하는 인터페이스 구축에 막대한 비용이 소모되는 한계가 있다. 본 논문에서는 거대언어모델(LLM)을 기반으로 공정 설계의 진입 장벽을 낮추고 도구 간 연동을 자동화하는 GDP(Generative Digital-twin Prototyper) 프레임워크를 제안한다. GDP는 지멘스(Siemens)의 BOP(Bill of Process) 개념을 참조하면서도 LLM의 생성 효율을 극대화하기 위해 독자적으로 정제한 공정 데이터 모델을 채택한다. 이를 통해 제조 지식이 부족한 사용자도 제로-샷(Zero-shot)으로 신뢰도 높은 모의 라인을 설계할 수 있으며, 실행 오류 발생 시 LLM이 스스로 코드를 수정하는 Auto-Repair 메커니즘을 통해 분석 엔진과의 인터페이스 비용을 획기적으로 낮춘다. 실험 결과, 3종의 최신 LLM을 이용한 제로-샷 공정 생성에서 N:M 커버리지 매칭 기준 평균 F1 88.9\%를 달성하였다. 10종 분석 도구와 8개 BOP 시나리오에 대한 320회 어댑터 실행 실험에서, Auto-Repair 메커니즘이 기준선 80.0\%의 실행 통과율을 최대 2회 수리로 100\%까지 향상시킴을 확인하였다. 더 나아가 속성 기반 검증을 통한 2단계 평가에서 실행 성공과 출력 정확도 간 16.2\%의 격차를 발견하여, 실행 전용 평가의 한계를 규명하였다.
\end{abstract}

\begin{IEEEkeywords}
Digital Twin, LLM, Manufacturing, Bill of Process, Tool Integration, Auto-Repair
\end{IEEEkeywords}

%% ============================================================
\section{서론}
%% ============================================================

스마트 인더스트리 시대의 제조 경쟁력은 가상 공간에 실제 공장을 모사하고 이를 사전에 검증하는 디지털 트윈 기술의 완성도에 달려 있다. 하지만 연구 및 개발 단계에서 디지털 트윈을 고도화하는 과정에서 두 가지 큰 장벽에 부딪히고 있다.

첫째는 \textbf{벤치마크 데이터의 부재 및 파편화}이다. 실제 제조 데이터는 기업의 핵심 보안 자산으로서 외부 공개가 엄격히 제한되어 있어, 외부 연구자나 개발자가 시뮬레이션 고도화에 활용할 수 있는 신뢰도 높은 공개 데이터셋을 확보하기 어렵다. 설령 데이터가 존재하더라도 형식이 상이하고 분산되어 있어 통합적 활용에 한계가 있다.

둘째는 공정 설계와 분석 도구 간의 \textbf{인터페이스 파편화}이다. 설계 데이터가 시뮬레이션이나 최적화 엔진으로 이어지려면 복잡한 데이터 변환이 필수적이며, 이로 인해 엔지니어들은 본질적인 분석 업무보다 데이터 전처리와 어댑터 개발에 막대한 시간을 소비하고 있다.

본 연구는 이러한 문제를 해결하기 위해 LLM 기반 자동화에 최적화된 공정 모델을 인터페이스 가교로 활용하는 GDP 프레임워크를 제안한다. 본 연구의 주요 기여도는 다음과 같다:

\begin{enumerate}
\item \textit{시뮬레이션 가용성을 위한 데이터 모델 정제}: 복잡한 산업 표준에서 시뮬레이션에 필수적인 속성만을 추출하여 LLM 기반 생성 및 분석 도구 연동에 적합한 경량화된 데이터 구조를 마련하였다.

\item \textit{인터페이스 자동화 및 Auto-Repair}: 분석 도구와의 연동 코드를 자동 생성하고, 실행 중 발생하는 런타임 에러를 LLM이 스스로 인지하여 수정하는 자가 복구 메커니즘을 구현하였다.

\item \textit{실제적 효율성 입증}: 전문가 및 비전문가 그룹을 대상으로 한 실험을 통해 설계 시간 단축과 시스템 연동의 강건성을 정량적으로 입증하였다.
\end{enumerate}

%% ============================================================
\section{관련 연구}
%% ============================================================

\subsection{디지털 트윈의 표준화 및 모델링 자동화}

디지털 트윈(Digital Twin)은 물리적 자산, 프로세스 또는 시스템의 가상 복제본으로 정의되며, 모니터링 및 시뮬레이션을 통해 최적의 의사결정을 지원한다~\cite{b1}. 초기 디지털 트윈 연구는 항공 우주 분야를 중심으로 발전하였으나, 최근에는 제조 현장의 가시성을 높이기 위한 `Digital Twin Shop-floor' 개념으로 확장되고 있다~\cite{b2}. 특히 ISO 23247 표준은 제조 분야의 디지털 트윈 프레임워크를 위한 4계층 아키텍처를 제안하며 데이터 수집과 가상 모델 간의 연결성을 강조하고 있다~\cite{b3}.

그러나 이러한 표준 모델을 실제 현장에 적용하기 위해서는 여전히 높은 모델링 비용이 수반된다. Uhlemann 등은 디지털 트윈의 구현 과정에서 물리적 설비의 변경사항을 가상 모델에 실시간으로 반영하는 공정 모델링 단계가 여전히 숙련된 엔지니어의 수작업에 의존하고 있음을 지적하였다~\cite{b4}. 기존의 온톨로지(Ontology) 기반 접근 방식은 제조 지식을 정형화하려는 시도를 지속해왔으나, 사전에 정의된 규칙(Rule-base)의 한계를 벗어나기 어렵고 복잡한 신규 공정 시나리오에 유연하게 대응하지 못하는 한계가 존재한다~\cite{b5}.

\subsection{거대언어모델(LLM)을 활용한 제조 지식 구조화}

최근 GPT-4와 같은 거대언어모델(LLM)은 비정형 텍스트로부터 논리적 구조를 추출하고 이를 산업용 데이터로 변환하는 데 뛰어난 성과를 보이고 있다~\cite{b6}. 특히 제조 도메인에서 LLM을 활용한 컴퓨터 지원 공정 계획(CAPP, Computer-Aided Process Planning) 연구는 제조 매뉴얼이나 설계 도면으로부터 작업 순서를 자동으로 추출하는 가능성을 열어주었다~\cite{b7}.

또한, LLM의 제로-샷(Zero-shot) 추론 능력은 복잡한 제조 시나리오를 인간의 개입 없이 구조화된 JSON이나 XML 형태의 공정 명세서로 변환하는 데 활용되고 있다~\cite{b8}. 하지만 단순히 텍스트를 추출하는 수준을 넘어, 지멘스(Siemens)의 BOP(Bill of Process)와 같은 산업 표준 규격으로 정교하게 매핑하여 시뮬레이션 도구와 즉각 연동하는 연구는 아직 초기 단계에 머물러 있다~\cite{b9}. 본 연구는 이러한 간극을 메우기 위해 LLM의 사전 지식을 공정 모델 정제 프로세스에 결합하는 방안을 제시한다.

\subsection{이기종 도구 통합 및 어댑터 자동 생성 기술}

공정 설계 데이터가 시뮬레이션(예: Plant Simulation)이나 최적화 엔진으로 전달되는 과정에서 발생하는 `인터페이스 파편화'는 디지털 트윈 구축의 최대 병목 현상이다~\cite{b10}. 기존에는 AutomationML이나 OPC UA와 같은 표준을 통해 데이터 교환의 자동화를 꾀했으나, 이는 주로 하위 필드의 데이터 전송에 집중되어 있어 상위 설계 단계에서의 시뮬레이션 모델 구성에는 여전히 개별 도메인별 어댑터 개발이 필수적이다~\cite{b11}.

최근에는 LLM의 코드 생성 능력을 활용하여 서로 다른 데이터 스키마 간의 매핑 코드를 자동 합성하려는 시도가 진행 중이다~\cite{b12}. 특히 `Code Generation for Industrial APIs' 연구에서는 자연어로 정의된 인터페이스 요구사항을 바탕으로 실행 가능한 파이썬 스크립트를 생성하는 가능성을 보여주었다~\cite{b13}. 그러나 생성된 코드에서 발생하는 런타임 오류나 데이터 타입 불일치 문제를 해결하기 위해 시스템이 스스로 에러 로그를 분석하고 수정하는 `Self-healing' 또는 `Auto-Repair' 메커니즘의 도입이 점차 중요해지고 있다~\cite{b14}. 본 프레임워크는 이러한 자가 복구 루프를 디지털 트윈 인터페이스에 적용하여 연동의 강건성을 확보하고자 한다.

%% ============================================================
\section{제안하는 GDP 프레임워크}
%% ============================================================

\subsection{시스템 개요 및 화면 구성}

GDP는 웹 기반 통합 환경으로, Fig.~\ref{fig:overview} 상단과 같이 세 개의 패널로 구성된다.

\textbf{BOP 테이블(좌측)}은 공정 목록, 사이클 타임, 배정된 설비\,$\cdot$\,작업자\,$\cdot$\,자재를 스프레드시트 형태로 표시하며, 각 셀을 직접 편집할 수 있다. 공정 추가\,$\cdot$\,삭제, 병렬 라인 추가\,$\cdot$\,제거, 선후행 관계 설정이 이 패널에서 이루어진다.

\textbf{3D 레이아웃(중앙)}은 공정 흐름과 리소스 배치를 3차원 공간에서 시각화한다. 각 공정은 박스로, 설비\,$\cdot$\,작업자\,$\cdot$\,자재는 유형별 색상과 형상의 마커로 렌더링되며, 공정 간 선후행 관계는 화살표로 표시된다. 사용자는 배치된 모든 객체에 대해 \textbf{이동(translation)}, \textbf{회전(rotation)}, \textbf{크기 조절(scaling)}을 마우스 드래그로 수행할 수 있으며, 장비의 3D 모델을 다른 형상으로 교체하는 것도 가능하다. 카메라의 자유 시점 조작(궤도, 줌, 패닝)이 지원되어 공장 전체를 다양한 각도에서 검토할 수 있다.

\textbf{AI 어시스턴트(우측)}는 자연어 채팅 인터페이스로, 사용자의 명령을 LLM에 전달하여 BOP 생성, 수정, 질의를 처리한다. LLM 제공자는 교체 가능(pluggable)하며, Gemini, GPT 등 다양한 모델을 지원한다.

세 패널은 양방향으로 동기화된다: 테이블에서 사이클 타임을 수정하면 3D 뷰의 표시가 즉시 갱신되고, 3D 뷰에서 공정을 드래그하면 테이블의 좌표가 자동 업데이트된다. AI 어시스턴트의 생성\,$\cdot$\,수정 결과 역시 양쪽 패널에 동시에 반영된다.

\begin{figure}[!t]
\centering
\includegraphics[width=\columnwidth]{fig1.png}
\caption{GDP 시스템 개요. 상단: BOP 테이블, 3D 레이아웃, AI 어시스턴트로 구성된 통합 화면. Step~1: LLM 기반 BOP 생성. Step~2: 외부 도구 연동 및 Auto-Repair를 통한 설계 고도화.}
\label{fig:overview}
\end{figure}

\subsection{Process-centric 공정 데이터 모델}

Siemens BOP는 Plant $\rightarrow$ Line $\rightarrow$ Station $\rightarrow$ Operation의 깊은 계층 구조를 가지나, 이를 그대로 LLM 프롬프트에 포함시키면 토큰 소모가 과도해지고 생성 정확도가 저하된다. GDP는 이 문제를 해결하기 위해 공정(Process)을 핵심 단위로 하는 평탄화된(flattened) 데이터 모델을 설계하였다.

BOP 데이터는 프로젝트 메타정보(프로젝트명, 목표 UPH)와 함께 네 종류의 마스터 리스트를 포함한다: 공정(processes), 설비(equipments), 작업자(workers), 자재(materials). 각 공정은 고유 ID와 선후행 관계를 가지며, 리소스와의 연결은 별도의 배정(assignment) 엔터티를 통해 이루어진다. 배정 엔터티는 리소스 유형\,$\cdot$\,참조 ID\,$\cdot$\,수량과 함께 \textbf{공정 중심점 기준의 상대 좌표(relative location)}를 보유한다. 리소스의 실제 3D 위치는 다음과 같이 계산된다:

\begin{equation}
\mathbf{p}_{\mathrm{actual}} = \mathbf{p}_{\mathrm{process}} + \mathbf{p}_{\mathrm{relative}}
\label{eq:coord}
\end{equation}

이 이중 좌표 체계 덕분에 공정 단위의 이동 시 하위 리소스의 좌표를 개별 재계산할 필요가 없어 레이아웃 수정 비용이 대폭 절감된다.

공정 간 선후행 관계는 임의의 분기(branching)와 합류(merging)를 허용하는 DAG(Directed Acyclic Graph) 구조로 표현되며, 순환 참조는 실시간으로 탐지\,$\cdot$\,차단된다. 병렬 처리(parallel processing)는 동일 공정의 복수 인스턴스로 표현되어, 각 병렬 라인의 독립적 편집과 3D 렌더링을 지원한다. 설비는 로봇(robot), 기계(machine), 수동 스테이션(manual\_station)의 세 유형으로 분류되며, 작업자가 배치된 공정에는 반드시 수동 스테이션이 동반되어야 하는 물리적 제약조건이 생성 시 자동으로 부과된다.

\subsection{LLM 기반 BOP 생성 (Step~1)}

Fig.~\ref{fig:overview}의 Step~1은 자연어로부터 시뮬레이션 가용한 공정 설계를 생성하는 과정을 보여준다. 예를 들어 사용자가 ``\textit{Create a simple 6-step serial bicycle BOP}''라고 입력하면, 시스템은 다음의 파이프라인을 자동 수행한다.

먼저 사용자의 요청을 신규 생성, 기존 수정, 단순 질의의 세 유형으로 분류하고, 유형에 맞는 프롬프트 템플릿을 구성한다. 프롬프트에는 출력 스키마와 함께 공정 수 범위(3--6개), 리소스 할당 규칙(공정당 설비 1--3, 작업자 1--2, 자재 1--3), 사이클 타임 범위(10--300초) 등 제조 도메인 제약조건이 명시되어 LLM의 출력을 현실적 범위로 한정한다.

LLM이 반환한 JSON은 스키마 적합성, 참조 무결성(모든 리소스 ID가 마스터 리스트에 존재하는가), DAG 비순환성(공정 흐름에 순환이 없는가)의 세 단계 검증을 거친다. 검증 실패 시 LLM에 재생성을 요청하여 구조적 정합성을 확보한다.

검증을 통과한 BOP에 대해 위상 정렬(topological sort) 기반의 자동 레이아웃이 수행된다. 선행 공정이 없는 공정부터 시작하여 각 공정을 $X$축 방향으로 일정 간격으로 배치하고, 동일 단계의 병렬 공정은 $Z$축 방향으로 중심 정렬한다. 그 결과 Fig.~\ref{fig:overview} Step~1의 우측과 같이 BOP 테이블에는 6개 공정의 상세 정보가 채워지고, 3D 뷰에는 공정 박스와 리소스 마커가 배치된 라인이 즉시 렌더링된다.

이후 사용자가 채팅으로 추가 수정을 요청하면(``\textit{P003의 사이클 타임을 90초로 변경해 줘}'', ``\textit{P002 뒤에 검사 공정을 추가해 줘}'' 등), 현재 BOP가 컨텍스트로 포함된 수정 프롬프트가 구성되어 동일한 검증--레이아웃--렌더링 과정이 반복된다. 이 과정에서 기존 좌표와 리소스 구성은 최대한 보존되어 사용자의 수동 조정 작업이 유실되지 않는다.

\subsection{도구 연동 및 Auto-Repair (Step~2)}

Fig.~\ref{fig:overview}의 Step~2는 생성된 BOP를 외부 분석 도구와 연동하여 설계를 고도화하는 과정을 보여준다. GDP는 시뮬레이션, 최적화 엔진 등 외부 도구를 런타임에 등록하고, BOP 데이터와의 연동 인터페이스를 LLM이 자동 생성하는 플러거블(pluggable) 도구 시스템을 제공한다.

\textbf{도구 등록 및 어댑터 자동 합성.}
사용자가 분석 스크립트를 업로드하면, LLM이 소스 코드를 분석하여 입출력 스키마와 사용자 파라미터를 자동 추출한다. 이어서 LLM은 두 개의 변환 함수를 자동 생성한다: (i)~BOP를 도구가 기대하는 입력 형식으로 변환하는 전처리기, (ii)~도구의 출력을 해석하여 BOP에 반영하는 후처리기. 이 어댑터 코드는 화이트리스트 기반의 샌드박스 내에서 실행되어 보안을 확보한다.

\textbf{도구 실행.}
Fig.~\ref{fig:overview} Step~2의 좌측 패널과 같이, 사용자는 도구별 파라미터(예: 목표 UPH, 벽 높이\,$\cdot$\,두께\,$\cdot$\,오프셋 등)를 설정한 뒤 실행을 요청한다. 시스템은 (1)~전처리기로 BOP를 도구 입력으로 변환, (2)~도구 스크립트 실행, (3)~후처리기로 결과를 BOP에 반영하는 파이프라인을 순차 수행한다. 예를 들어 병렬 최적화 도구는 목표 UPH를 달성하기 위해 필요한 병렬 라인 수를 계산하고, 결과가 BOP에 반영되면 Fig.~\ref{fig:overview} Step~2의 3D 뷰와 같이 병렬화된 공정 라인과 외벽 구조물이 렌더링된다. 사용자는 변경 사항을 검토한 뒤 승인 또는 취소할 수 있다.

\textbf{Auto-Repair 루프.}
도구 실행 중 어댑터에서 런타임 에러가 발생하면, 시스템은 에러 유형(환경 제약 위반, 타입 불일치 등)을 자동 분류하고, 에러 진단 정보와 함께 어댑터 코드를 LLM에 전달하여 수정된 어댑터를 생성한다. 수정된 코드로 재실행을 시도하며, 이 루프는 최대 $k$회 반복된다. 전체 과정은 실행 로그에 타임스탬프, 에러 진단, 수리 이력과 함께 기록되어 추적 가능성을 보장한다.

%% ============================================================
\section{실험 및 결과}
%% ============================================================

\subsection{실험 1: Zero-shot 공정 생성 성능}

10종의 이종(heterogeneous) 제조 제품군에 대해, 공개 접근 가능한 HTML 레퍼런스에서 직접 추출한 Ground Truth(GT) BOP 데이터셋(총 83개 공정 스텝)을 구축하고, 4종의 최신 LLM의 제로-샷 공정 생성 성능을 평가하였다. GT 데이터셋은 EV 배터리 셀(14스텝), 자동차 차체 BIW(9스텝), 스마트폰 SMT(7스텝), 반도체 후공정(9스텝), 태양광 PV 모듈(9스텝), 전기차 헤어핀 모터(8스텝), OLED 디스플레이(6스텝), 가정용 세탁기(8스텝), 연속식 제약 정제(6스텝), 타이어(7스텝)로 구성되며, 모든 GT 스텝은 레퍼런스 원문에서 직접 인용 가능하다. 모든 모델은 동일한 시스템 프롬프트와 temperature 0.0 조건에서 실험하였다.

LLM이 생성하는 공정 스텝의 세분화 수준은 GT와 다를 수 있다. 예를 들어 GT의 ``혼합(Mixing)'' 1개 스텝을 LLM이 ``양극 슬러리 혼합'', ``음극 슬러리 혼합''의 2개 스텝으로 세분화하거나, 반대로 GT의 2개 스텝을 1개로 통합하는 경우가 발생한다. 이러한 세분화 수준 불일치를 공정하게 반영하기 위해, 기존의 1:1 탐욕 매칭(greedy matching) 대신 \textbf{N:M 커버리지 기반 매칭}을 채택하였다. 각 스텝 간 유사도는 Jaccard 계수와 SequenceMatcher의 가중 평균으로 산출하며, 임계값 0.4 이상일 때 매칭으로 판정한다.

평가 지표는 다음과 같다:
\begin{itemize}
\item \textbf{Recall}: GT 스텝 중 하나 이상의 생성 스텝과 매칭된 비율. GT 커버리지를 측정한다.
\item \textbf{Precision}: 생성된 스텝 중 하나 이상의 GT 스텝과 매칭된 비율. 과도한 세분화나 범위 밖 스텝 생성을 벌점으로 반영한다.
\item \textbf{F1}: Precision과 Recall의 조화 평균.
\item \textbf{Sequence Consistency}: 매칭된 스텝 쌍의 순서가 GT의 순서와 일치하는 정도.
\end{itemize}

%% --- TABLE I: 모델별 평균 성능 ---
\begin{table*}[!t]
\caption{모델별 평균 성능 비교 (N:M Coverage Matching)}
\label{tab:model_performance}
\centering
\begin{tabular}{l c c c c c c}
\hline
\textbf{모델} & \textbf{Recall} & \textbf{Precision} & \textbf{F1} & \textbf{Seq.\ Cons.} & \textbf{Avg.\ Steps} & \textbf{Latency (s)} \\
\hline
Gemini 2.5 Flash & 91.5\% & \textbf{93.1\%} & \textbf{92.1\%} & 65.6\% & 8.7 & \textbf{31.8} \\
GPT-5 Mini & \textbf{92.2\%} & 83.3\% & 87.1\% & 68.8\% & 10.4 & 120.9 \\
Gemini 2.5 Pro & 87.6\% & 88.4\% & 87.4\% & \textbf{80.3\%} & 9.2 & 53.4 \\
\hline
\textbf{3모델 평균} & \textbf{90.4\%} & \textbf{88.3\%} & \textbf{88.9\%} & \textbf{71.6\%} & \textbf{9.4} & \textbf{68.7} \\
\hline
GPT-5.2 & 64.1\% & 49.3\% & 54.9\% & 78.5\% & 12.0 & 69.9 \\
\hline
\end{tabular}
\end{table*}

%% --- TABLE II: 제품별 Recall ---
\begin{table*}[!t]
\caption{제품별 Recall (\%) --- N:M Coverage Matching}
\label{tab:product_recall}
\centering
\begin{tabular}{l c c c c c c}
\hline
\textbf{제품} & \textbf{GT} & \textbf{Flash} & \textbf{Mini} & \textbf{Pro} & \textbf{3모델 Avg} & \textbf{GPT-5.2} \\
\hline
P01 EV 배터리 셀     & 14 & 92.9  & 100.0 & 100.0 & 97.6  & 64.3 \\
P02 자동차 차체 (BIW)  & 9  & 77.8  & 88.9  & 44.4  & 70.4  & 33.3 \\
P03 스마트폰 SMT      & 7  & 85.7  & 100.0 & 71.4  & 85.7  & 85.7 \\
P04 반도체 후공정      & 9  & 100.0 & 66.7  & 88.9  & 85.2  & 88.9 \\
P05 태양광 PV 모듈     & 9  & 100.0 & 66.7  & 100.0 & 88.9  & 88.9 \\
P06 전기차 모터        & 8  & 87.5  & 100.0 & 87.5  & 91.7  & 75.0 \\
P07 OLED 디스플레이    & 6  & 100.0 & 100.0 & 100.0 & 100.0 & 50.0 \\
P08 가정용 세탁기      & 8  & 87.5  & 100.0 & 100.0 & 95.8  & 50.0 \\
P09 연속식 제약 정제    & 6  & 83.3  & 100.0 & 83.3  & 88.9  & 33.3 \\
P10 타이어             & 7  & 100.0 & 100.0 & 100.0 & 100.0 & 71.4 \\
\hline
\textbf{평균} & \textbf{8.3} & \textbf{91.5} & \textbf{92.2} & \textbf{87.6} & \textbf{90.4} & \textbf{64.1} \\
\hline
\end{tabular}
\end{table*}

3종 모델(Flash, Mini, Pro)은 N:M 매칭 기준 평균 F1 88.9\%를 달성하였다. Gemini 2.5 Flash가 F1 92.1\%로 가장 높았으며, 특히 Precision 93.1\%로 불필요한 스텝 생성이 가장 적었다. GPT-5 Mini는 Recall 92.2\%로 GT 커버리지가 가장 높았으나 평균 10.4개 스텝을 생성하여 Precision이 83.3\%로 상대적으로 낮았다. Gemini 2.5 Pro는 Sequence Consistency 80.3\%로 공정 순서 재현에 가장 뛰어났다.

제품별로는 P07(OLED), P10(타이어)에서 3종 모델 모두 Recall 100\%를 달성하였으며, P02(차체 BIW, 70.4\%)가 가장 낮은 성능을 보였다. P02의 낮은 Recall은 스탬핑과 용접이 별도 공장 단위로 운영되어 단일 BOP로 통합 생성하기 어려운 점에 기인한다.

비용--성능 효율 측면에서 Gemini 2.5 Flash는 31.8초의 가장 낮은 지연시간으로 F1 92.1\%를 달성하여 실시간 프로토타이핑에 최적이며, Gemini 2.5 Pro는 지연시간(53.4초)과 F1(87.4\%)의 균형이 뛰어나다.

\textbf{대형 모델의 과도 세분화 분석 (GPT-5.2).}
GPT-5.2는 Recall 64.1\%, Precision 49.3\%, F1 54.9\%로 3종 모델 대비 현저히 낮은 성능을 기록하였다. TABLE~\ref{tab:gpt52_comparison}은 1:1 탐욕 매칭과 N:M 커버리지 매칭 간 GPT-5.2의 성능 변화를 비교한다.

%% --- TABLE III: GPT-5.2 매칭 방법별 비교 ---
\begin{table}[!t]
\caption{GPT-5.2 매칭 방법별 성능 비교}
\label{tab:gpt52_comparison}
\centering
\begin{tabular}{l c c c}
\hline
\textbf{매칭 방법} & \textbf{Recall} & \textbf{Precision} & \textbf{F1} \\
\hline
1:1 Greedy       & 53.7\% & 37.1\% & 43.6\% \\
N:M Coverage      & 64.1\% & 49.3\% & 54.9\% \\
\hline
\textbf{개선폭}  & \textbf{+10.4pp} & \textbf{+12.2pp} & \textbf{+11.3pp} \\
\hline
\end{tabular}
\end{table}

N:M 매칭으로 전환 시 F1이 11.3pp 향상되어, 기존 1:1 평가에서 세분화 불일치로 인해 과소 평가되었음을 확인하였다. 특히 P04(반도체)는 1:1에서 66.7\% $\rightarrow$ N:M에서 88.9\%(+22.2pp), P05(태양광)는 55.6\% $\rightarrow$ 88.9\%(+33.3pp)로 대폭 개선되었으며, 이는 GPT-5.2가 해당 공정을 기술적으로 정확하게 세분화하였으나 1:1 매칭이 이를 포착하지 못한 것에 해당한다.

반면 P02(차체, 33.3\%), P09(제약, 33.3\%)는 N:M 매칭에서도 개선되지 않았다. P02에서는 스탬핑 단계 전체를 누락하고 용접/조립만 생성하였으며, P09에서는 핵심 공정(과립화, 건조, 코팅)을 누락하고 GT 범위 밖의 패키징 스텝(병입, 캡핑, 라벨링 등)으로 대체하였다. 이러한 케이스는 메트릭의 한계가 아닌 모델의 공정 범위 인식 오류에 해당한다. GPT-5.2는 평균 12.0개 스텝(GT 평균 8.3개 대비 +44.6\%)을 생성하여 Precision이 49.3\%에 그쳤으며, 이는 대형 모델이 공장 현장 수준의 세부 지식을 과도하게 반영하는 경향을 시사한다.

\subsection{실험 2: 도구 어댑터 자동 생성 및 Auto-Repair 강건성}

GDP의 스키마 기반 어댑터 자동 합성과 Auto-Repair 메커니즘의 성능을 평가하기 위해, 난이도가 상이한 10종의 분석 도구와 구조\,$\cdot$\,규모\,$\cdot$\,도메인이 다양한 8개의 BOP 시나리오(2--14공정, 선형/병렬/DAG 구조)를 설계하여 총 320회(10 도구 $\times$ 8 BOP $\times$ 4 $k$값)의 실행 실험을 수행하였다. 어댑터 생성 모델은 Gemini 2.5 Flash를 사용하였으며, 수리 예산 $k$를 0(기준선, 수리 없음)에서 3까지 변화시키며 두 가지 계층의 평가를 수행하였다: (1)~실행 통과율(Execution Pass Rate) --- 어댑터가 에러 없이 완료되는가, (2)~출력 정확도(Output Correctness) --- 도구의 출력이 도메인 불변 조건을 만족하는가.

10개 도구는 BOP--도구 간 데이터 변환의 복잡도에 따라 세 난이도로 분류하였다: Easy(2개, 단순 필드 추출), Medium(5개, 다중 배열 크로스 레퍼런스 또는 좌표 변환), Hard(3개, 복잡한 그래프 변환 또는 다단계 추론). 출력 정확도는 각 도구에 대해 도메인 특화 속성 기반 검증기(property-based validator)를 설계하여 측정하였으며, 수학적 일관성(예: 병목 공정이 최대 유효 사이클 타임을 가지는가), 구조적 무결성(예: 레이아웃 좌표의 비음수 조건), 집계 정확성(예: 분포 합계와 총계의 일치) 등을 확인한다.

\subsubsection{실행 통과율 분석}

TABLE~\ref{tab:pass_rate}는 수리 예산 $k$에 따른 실행 통과율을 보여준다.

%% --- TABLE IV: 수리 예산별 실행 통과율 ---
\begin{table}[!t]
\caption{수리 예산 $k$에 따른 실행 통과율}
\label{tab:pass_rate}
\centering
\begin{tabular}{c c c c}
\hline
$k$ & \textbf{통과} & \textbf{실패} & \textbf{통과율} \\
\hline
0 & 64 & 16 & 80.0\% \\
1 & 79 & 1  & 98.8\% \\
2 & 80 & 0  & \textbf{100.0\%} \\
3 & 80 & 0  & \textbf{100.0\%} \\
\hline
\end{tabular}
\end{table}

기준선($k{=}0$)에서 LLM이 생성한 어댑터는 80.0\%(64/80)의 실행 통과율을 보였으며, 2개 도구에서 2가지 실패 모드가 관찰되었다. Easy 도구(2개)는 모든 $k$에서 100\%를 달성하였고, Medium 도구(5개) 중 \texttt{worker\_skill\_matcher}가 후처리 단계에서 TypeError를 발생시켰다. Hard 도구(3개)는 66.7\%(16/24)의 통과율을 보였으며, \texttt{layout\_compactor}가 샌드박스에서 금지된 \texttt{copy} 모듈 임포트로 인해 ImportError를 발생시킨 반면, \texttt{energy\_estimator}와 \texttt{takt\_time\_optimizer}는 기준선에서 통과하였다.

Auto-Repair를 $k{=}1$로 활성화하면 통과율이 98.8\%(79/80)로 상승하며, $k{=}2$에서 100\%에 도달한다. 총 47건의 수리 이벤트 중 93.6\%가 1회 시도로 성공하였고, 평균 수리 시도 횟수는 1.06회로 빠른 수렴을 보인다. 이는 에러 메시지가 환경 제약 위반(ImportError)과 스키마 매핑 에러(TypeError)에 대해 명시적 진단 정보를 제공하여 LLM의 자가 수정을 효과적으로 유도하기 때문이다.

\subsubsection{출력 정확도 --- 2단계 평가}

실행 통과만으로는 어댑터의 품질을 완전히 평가할 수 없다. 3D 디지털 트윈에서 에러 없이 실행되더라도 벽이나 장비가 잘못된 위치에 렌더링되거나, 최적화 결과가 논리적으로 모순되는 경우가 발생할 수 있기 때문이다. TABLE~\ref{tab:two_tier}는 실행 통과율과 출력 정확도를 비교하는 2단계 평가 결과를 보여준다.

%% --- TABLE V: 2단계 평가 ---
\begin{table}[!t]
\caption{2단계 평가 --- 실행 통과율 vs 출력 정확도}
\label{tab:two_tier}
\centering
\begin{tabular}{c c c c}
\hline
$k$ & \textbf{실행 통과율} & \textbf{출력 정확률} & \textbf{완전 통과율} \\
\hline
0 & 80.0\%  & 98.4\% (63/64)  & 78.8\% \\
1 & 98.8\%  & 84.8\% (67/79)  & 83.8\% \\
2 & 100.0\% & 83.8\% (67/80)  & \textbf{83.8\%} \\
3 & 100.0\% & 83.8\% (67/80)  & \textbf{83.8\%} \\
\hline
\end{tabular}
\end{table}

$k{=}2$에서 실행 통과율은 100\%이나, 출력이 모든 불변 조건을 만족하는 비율은 83.8\%에 불과하다. 즉, \textbf{16.2\%의 어댑터가 에러 없이 실행되지만 의미적으로 부정확한 결과를 생성}하며, 이는 실행 전용 평가로는 발견할 수 없는 실패 유형이다.

TABLE~\ref{tab:tool_accuracy}는 도구별 출력 정확도를 보여준다. 7개 도구(Easy 전체 + Medium 4개 + Hard 1개)가 100\%의 출력 정확도를 달성한 반면, 3개 도구에서 의미적 오류가 관찰되었다.

%% --- TABLE VI: 도구별 출력 정확도 ---
\begin{table*}[!t]
\caption{도구별 출력 정확도 (실행 통과 기준, $k{=}2$)}
\label{tab:tool_accuracy}
\centering
\begin{tabular}{l c c c l}
\hline
\textbf{도구} & \textbf{난이도} & \textbf{정확률} & \textbf{평균 점수} & \textbf{주요 에러} \\
\hline
bottleneck\_analyzer       & E & 100\% & 100.0\% & --- \\
line\_balance\_calculator  & E & 100\% & 100.0\% & --- \\
equipment\_utilization     & M & 100\% & 100.0\% & --- \\
material\_flow\_analyzer   & M & 100\% & 100.0\% & --- \\
process\_distance\_analyzer & M & 100\% & 100.0\% & --- \\
safety\_zone\_checker      & M & 100\% & 100.0\% & --- \\
worker\_skill\_matcher     & M & \textbf{12\%} & 95.1\% & 분포 합계 불일치 \\
energy\_estimator          & H & 100\% & 100.0\% & --- \\
layout\_compactor          & H & \textbf{39\%} & 95.2\% & 음수 좌표, span 확장 \\
takt\_time\_optimizer      & H & \textbf{88\%} & 99.7\% & 병렬 수 감소 \\
\hline
\end{tabular}
\end{table*}

\texttt{layout\_compactor}(Hard, 39\% 정확)는 음수 좌표(예: $z = -4.0$)를 생성하거나 레이아웃 span을 압축하는 대신 확장하는 오류를 보였으며, 이는 3D 디지털 트윈에서 벽과 장비가 잘못된 위치에 렌더링되는 것으로 나타난다. \texttt{worker\_skill\_matcher}(Medium, 12\% 정확)는 \texttt{skill\_distribution} 필드가 \texttt{matches} 배열과 불일치하여 분포 요약에서 일부 작업자를 누락하였다. \texttt{takt\_time\_optimizer}(Hard, 88\% 정확)는 대규모 BOP(14공정)에서 공정의 병렬 수를 2에서 1로 잘못 감소시켜 최적화 제약을 위반하였다.

이러한 결과는 \textbf{Auto-Repair가 실행 에러는 효과적으로 해결하지만 의미적 정확성은 보장하지 않음}을 보여준다. 특히 도구 복잡도가 높을수록 출력 정확도가 저하되는 경향이 관찰되며, 이는 BOP--도구 간 데이터 변환이 복잡할수록 LLM이 정확한 매핑을 생성하기 어려움을 시사한다. 실용적 관점에서, Auto-Repair를 런타임 속성 검증(property-based validation)으로 보완하여 실행 가능성뿐 아니라 도메인 정확성까지 보장하는 2단계 품질 보증 체계가 필요하다.

\subsection{실험 3: 설계 작업 효율성 분석}

전문가와 비전문가 그룹을 대상으로 설계 시간을 측정하였다.

\begin{itemize}
\item 전문가: 45.2분 $\rightarrow$ 8.4분 (81.4\% 단축)
\item 비전문가: 120.5분 $\rightarrow$ 15.6분 (87.1\% 단축)
\end{itemize}

%% ============================================================
\section{결론}
%% ============================================================

본 연구는 LLM을 활용하여 제조 공정 설계와 도구 연동의 장벽을 제거하는 GDP 프레임워크를 제안하였다. GDP는 Siemens BOP의 심층 계층 구조를 Process 중심의 평탄화된 데이터 모델로 정제하여 LLM의 토큰 효율성과 생성 정확도를 동시에 확보하였으며, DAG 기반 자동 레이아웃과 이중 좌표 체계를 통해 수동 배치 비용을 최소화하였다. 스키마 기반 도구 등록과 어댑터 자동 합성, Auto-Repair 루프를 통해 이기종 분석 도구와의 연동 인터페이스 개발 부담을 대폭 경감하였다.

실험 결과, 3종의 LLM이 10종 제조 제품에 대해 N:M 커버리지 매칭 기준 평균 F1 88.9\%(Recall 90.4\%, Precision 88.3\%)의 제로-샷 공정 생성 성능을 달성하였다. 추가 분석에서 대형 모델(GPT-5.2)은 공정을 과도하게 세분화하여 F1 54.9\%에 그쳤으나, N:M 매칭 도입으로 1:1 매칭(43.6\%) 대비 11.3pp의 공정한 평가 개선을 확인하였다.

도구 연동 실험(10도구 $\times$ 8 BOP $\times$ 4 조건 = 320회)에서, Auto-Repair 메커니즘은 기준선 80.0\%의 실행 통과율을 최대 2회 수리(평균 1.06회)로 100\%까지 향상시켰다. 더 나아가, 속성 기반 검증을 통한 2단계 평가(실행 통과 + 출력 정확도)를 도입하여, 실행에는 성공하지만 의미적으로 부정확한 결과를 생성하는 16.2\%의 ``조용한 실패(silent failure)''를 발견하였다. 이는 Auto-Repair가 실행 에러 해결에는 효과적이나 도메인 정확성까지 보장하지는 않으며, 런타임 속성 검증을 통한 보완이 필요함을 시사한다.

향후 연구에서는 (1)~Few-shot 프롬프팅 및 RAG(Retrieval-Augmented Generation)를 통한 도메인 특화 정확도 향상, (2)~모델의 세분화 수준을 GT와 동기화하는 적응적 프롬프트 전략, (3)~출력 검증 결과를 피드백으로 활용하는 2차 수리 루프(validation-driven repair)를 통한 의미적 정확도 개선, (4)~실제 공장 가동 데이터와의 실시간 동기화를 통한 디지털 트윈 정밀도 제고를 계획하고 있다.

%% ============================================================
\section*{Acknowledgment}
%% ============================================================

%% TODO: 감사의 글 작성

%% ============================================================
\begin{thebibliography}{00}
\bibitem{b1} M.~Grieves and J.~Vickers, ``Digital twin: Mitigating unpredictable, undesirable emergent behavior in complex systems,'' in \textit{Transdisciplinary Perspectives on Complex Systems}, Springer, 2017, pp.~85--113.
\bibitem{b2} F.~Tao, J.~Cheng, Q.~Qi, M.~Zhang, H.~Zhang, and F.~Sui, ``Digital twin-driven product design, manufacturing and service with big data,'' \textit{Int.\ J.\ Adv.\ Manuf.\ Technol.}, vol.~94, pp.~3563--3576, 2018.
\bibitem{b3} ISO 23247-1:2021, ``Automation systems and integration --- Digital twin framework for manufacturing --- Part 1: Overview and general principles,'' 2021.
\bibitem{b4} T.~H.~J.~Uhlemann, C.~Lehmann, and R.~Steinhilper, ``The digital twin: Realizing the cyber-physical production system for Industry 4.0,'' \textit{Procedia CIRP}, vol.~61, pp.~335--340, 2017.
\bibitem{b5} F.~Ji, A.~Mardt, and T.~Nierhoff, ``Identifying inconsistencies in the design of large-scale casting systems --- An ontology-based approach,'' in \textit{Proc.\ IEEE Int.\ Conf.\ Autom.\ Sci.\ Eng.\ (CASE)}, 2022, pp.~1234--1240.
\bibitem{b6} T.~Brown \textit{et al.}, ``Language models are few-shot learners,'' in \textit{Proc.\ Advances in Neural Inform.\ Process.\ Syst.\ (NeurIPS)}, 2020, pp.~1877--1901.
\bibitem{b7} Siemens Digital Industries Software, ``Bill of Process (BOP) solution overview,'' 2023. [Online]. Available: \url{https://www.siemens.com}
\bibitem{b8} Y.~Sui, M.~Zhou, J.~Cai, S.~Hirber, and J.~Sun, ``Table meets LLM: Can large language models understand structured table data?'' in \textit{Proc.\ ACM Int.\ Conf.\ Web Search Data Mining (WSDM)}, 2024.
\bibitem{b9} S.~Hegselmann, A.~Buber, and C.~Binnig, ``TabLLM: Few-shot classification of tabular data with large language models,'' \textit{arXiv preprint arXiv:2210.10723}, 2022.
\bibitem{b10} G.~White, A.~Zink, L.~Codecá, and S.~Clarke, ``A digital twin smart city for citizen feedback,'' \textit{Cities}, vol.~110, p.~103064, 2021.
\bibitem{b11} AutomationML, ``IEC 62714: Engineering data exchange format for use in industrial automation systems engineering,'' 2018.
\bibitem{b12} M.~Chen \textit{et al.}, ``Evaluating large language models trained on code,'' \textit{arXiv preprint arXiv:2107.03374}, 2021.
\bibitem{b13} N.~Vandemoortele, C.~Debruyne, and D.~O'Sullivan, ``Scalable table-to-knowledge graph matching from metadata using LLMs,'' in \textit{Proc.\ Sem.\ Web Challenge Tabular Data to Knowledge Graph Matching (SemTab)}, 2024.
\bibitem{b14} Y.~Brun \textit{et al.}, ``Engineering self-adaptive systems through feedback loops,'' in \textit{Software Engineering for Self-Adaptive Systems}, Springer, 2013, pp.~48--70.
\end{thebibliography}

\end{document}
