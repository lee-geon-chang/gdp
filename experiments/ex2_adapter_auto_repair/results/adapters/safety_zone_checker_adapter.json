{
  "tool_id": "safety_zone_checker",
  "pre_process_code": "import json\n\ndef convert_bop_to_input(bop_json: dict, params: dict) -> str:\n    tool_processes = []\n    tool_obstacles = []\n\n    # Convert BOP process_details to tool's 'processes' format\n    # BOP's location is assumed to be the center of the base for Y-up system (Y-axis is height, floor is 0).\n    # BOP's computed_size provides width, height, depth.\n    # The tool expects x, y, z as the minimum corner of the bounding box.\n    for detail in bop_json.get('process_details', []):\n        process_id_bop = detail.get('process_id')\n        parallel_index = detail.get('parallel_index', 1) # Default to 1 if not specified\n        \n        # Construct a unique ID for the tool input for each process instance.\n        # This allows distinguishing between 'P001' instance 1 and 'P001' instance 2 in the tool's flat list.\n        # The tool output will use this combined ID to refer back to specific instances.\n        tool_process_id = f\"{process_id_bop}_{parallel_index}\" if process_id_bop else f\"UnnamedProcess_{parallel_index}\"\n\n        location = detail.get('location', {'x': 0.0, 'y': 0.0, 'z': 0.0})\n        computed_size = detail.get('computed_size', {'width': 1.0, 'height': 1.0, 'depth': 1.0})\n\n        # Calculate min_corner (x,y,z) for the tool's bounding box.\n        # Assuming BOP's location.y is the base (min y) of the object.\n        min_x = location['x'] - computed_size['width'] / 2\n        min_y = location['y'] # Y-up, floor=0, so location.y is often the base Y\n        min_z = location['z'] - computed_size['depth'] / 2\n\n        tool_processes.append({\n            \"process_id\": tool_process_id,\n            \"name\": detail.get('name', process_id_bop), # Use BOP's name, fallback to process_id\n            \"x\": min_x,\n            \"y\": min_y,\n            \"z\": min_z,\n            \"width\": computed_size['width'],\n            \"height\": computed_size['height'],\n            \"depth\": computed_size['depth']\n        })\n\n    # Convert BOP obstacles to tool's 'obstacles' format.\n    # BOP's position is assumed to be the center of the base for Y-up system.\n    # BOP schema explicitly states obstacles.position.y: 0, confirming it's the base.\n    # BOP's size provides width, height, depth.\n    # The tool expects x, y, z as the minimum corner of the bounding box.\n    for obs in bop_json.get('obstacles', []):\n        obstacle_id = obs.get('obstacle_id')\n        position = obs.get('position', {'x': 0.0, 'y': 0.0, 'z': 0.0})\n        size = obs.get('size', {'width': 0.5, 'height': 0.5, 'depth': 0.5}) # Default size\n\n        # Calculate min_corner (x,y,z) for the tool's bounding box.\n        min_x = position['x'] - size['width'] / 2\n        min_y = position['y'] # As per BOP schema, obstacle Y is typically 0\n        min_z = position['z'] - size['depth'] / 2\n\n        tool_obstacles.append({\n            \"obstacle_id\": obstacle_id,\n            \"name\": obs.get('name', obstacle_id), # Use BOP's name, fallback to obstacle_id\n            \"type\": obs.get('type', 'unknown'), # BOP includes 'type' for obstacles\n            \"x\": min_x,\n            \"y\": min_y,\n            \"z\": min_z,\n            \"width\": size['width'],\n            \"height\": size['height'],\n            \"depth\": size['depth']\n        })\n\n    # Include user-provided parameters directly in the tool input.\n    # Access params using .get() with a default value.\n    min_safety_distance = params.get('min_safety_distance', 1.0)\n\n    tool_input = {\n        \"processes\": tool_processes,\n        \"obstacles\": tool_obstacles,\n        \"min_safety_distance\": min_safety_distance\n    }\n\n    return json.dumps(tool_input, ensure_ascii=False)\n",
  "post_process_code": "import copy\n\ndef apply_result_to_bop(bop_json: dict, tool_output: dict) -> dict:\n    # CRITICAL: tool_output is ALREADY PARSED as dict. DO NOT call json.loads().\n    \n    # Create a deep copy of the original BOP JSON to avoid modifying it directly \n    # and ensure all original fields are preserved.\n    updated_bop = copy.deepcopy(bop_json)\n\n    # Store the entire tool output under a new 'analysis_results.safety_zone_checker' field.\n    # This ensures all detailed results from the tool are preserved in the BOP.\n    if 'analysis_results' not in updated_bop:\n        updated_bop['analysis_results'] = {}\n    \n    updated_bop['analysis_results']['safety_zone_checker'] = tool_output\n\n    # Prepare sets for quick lookup of violating and safe process instances\n    violating_instances = set()\n    for violation in tool_output.get('violations', []):\n        violating_instances.add(violation['process_id'])\n\n    safe_instances = set(tool_output.get('safe_processes', []))\n\n    # Iterate through BOP's process_details and add a 'safety_status' field to each instance.\n    # This allows for immediate visual feedback or filtering within the BOP context.\n    for detail in updated_bop.get('process_details', []):\n        process_id_bop = detail.get('process_id')\n        parallel_index = detail.get('parallel_index', 1)\n        \n        # Reconstruct the unique ID that was sent to the tool (e.g., \"P001_1\").\n        tool_process_id = f\"{process_id_bop}_{parallel_index}\" if process_id_bop else f\"UnnamedProcess_{parallel_index}\"\n\n        # Assign safety status based on tool's output.\n        if tool_process_id in violating_instances:\n            detail['safety_status'] = 'violation'\n        elif tool_process_id in safe_instances:\n            detail['safety_status'] = 'safe'\n        else:\n            # If a process instance is neither in violations nor explicitly safe,\n            # it might be due to tool logic (e.g., no obstacles nearby, or an edge case).\n            detail['safety_status'] = 'unknown_status'\n            \n    # Note on \"CRITICAL â€” Parallel Instance Creation Rules\":\n    # The Safety Zone Checker tool's output format (violations, safe_processes) does not \n    # include modifications to existing process locations/sizes, nor does it define new process instances.\n    # Therefore, the rules regarding location offsets and resource assignment for new instances\n    # are not applicable to this specific tool's integration via this adapter.\n    # This adapter only adds analytical results and status metadata to the existing BOP structure.\n\n    return updated_bop\n",
  "model": "gemini-2.5-flash",
  "generated_at": "2026-02-15T14:49:31.312837"
}