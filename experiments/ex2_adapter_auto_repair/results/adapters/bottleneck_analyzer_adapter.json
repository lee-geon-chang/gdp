{
  "tool_id": "bottleneck_analyzer",
  "pre_process_code": "import json\nimport math # Included as per \"Allowed stdlib modules ONLY\" rule, even if not strictly used for this specific tool.\nimport copy # Included as per \"Allowed stdlib modules ONLY\" rule.\n\ndef convert_bop_to_input(bop_json: dict, params: dict) -> str:\n    \"\"\"\n    Converts BOP data into the input format required by the Bottleneck Analyzer tool.\n    \n    Args:\n        bop_json (dict): The input BOP data in dictionary format.\n        params (dict): A dictionary of user-configurable parameters from the UI.\n\n    Returns:\n        str: A JSON string formatted for the Bottleneck Analyzer tool.\n    \"\"\"\n    tool_process_details = []\n    \n    # Extract process_details from BOP. The tool expects process_id, parallel_index,\n    # cycle_time_sec, and name for each entry.\n    for detail in bop_json.get('process_details', []):\n        tool_process_details.append({\n            \"process_id\": detail.get('process_id', 'UNKNOWN_PROCESS'),\n            \"parallel_index\": detail.get('parallel_index', 0), # Default to 0 if not present, consistent with tool's input example\n            \"cycle_time_sec\": detail.get('cycle_time_sec', 0.0),\n            \"name\": detail.get('name', 'Unnamed Process')\n        })\n\n    # Extract target_uph from BOP. Provide a default if it's missing from BOP.\n    # The tool's source code uses a default of 60 if not provided in its input.\n    target_uph = bop_json.get('target_uph', 60.0)\n\n    # Construct the tool's input JSON structure.\n    tool_input = {\n        \"process_details\": tool_process_details,\n        \"target_uph\": target_uph\n    }\n    \n    # IMPORTANT NOTE on 'params':\n    # The general instruction states to include all user parameters from 'params' in the tool input.\n    # However, the Bottleneck Analyzer tool's explicit `Input` schema and source code show it only\n    # consumes \"process_details\" and \"target_uph\". Adding other fields from `params` (like 'threshold')\n    # would be ignored by this specific tool and could cause issues if the input is shared with other tools.\n    # Therefore, we strictly adhere to the Bottleneck Analyzer's defined input fields for this adapter.\n    \n    return json.dumps(tool_input, ensure_ascii=False)\n",
  "post_process_code": "import json\nimport math # Included as per \"Allowed stdlib modules ONLY\" rule, even if not strictly used for this specific tool.\nimport copy # Included as per \"Allowed stdlib modules ONLY\" rule.\n\ndef apply_result_to_bop(bop_json: dict, tool_output: dict) -> dict:\n    \"\"\"\n    Applies the results from the Bottleneck Analyzer tool back to the BOP data.\n\n    Args:\n        bop_json (dict): The original BOP data in dictionary format.\n        tool_output (dict): The parsed output from the Bottleneck Analyzer tool.\n                            (CRITICAL: This is already a dict, do NOT call json.loads()).\n\n    Returns:\n        dict: The updated BOP data with bottleneck analysis results.\n    \"\"\"\n    # Create a deep copy of the original BOP to ensure all existing fields are preserved\n    # and to avoid modifying the input dictionary directly unless intended.\n    updated_bop = copy.deepcopy(bop_json)\n\n    # The BOP schema does not have direct fields for bottleneck analysis results.\n    # Therefore, we will add a new top-level key to store all relevant analysis findings.\n    # This approach keeps the core BOP structure intact while attaching valuable insights.\n    analysis_results = {\n        \"bottleneck_process_id\": tool_output.get(\"bottleneck_process_id\"),\n        \"bottleneck_process_name\": tool_output.get(\"bottleneck_process_name\"),\n        \"bottleneck_cycle_time_sec\": tool_output.get(\"bottleneck_cycle_time_sec\"),\n        \"effective_cycle_time_sec\": tool_output.get(\"effective_cycle_time_sec\"),\n        \"current_max_uph\": tool_output.get(\"current_max_uph\"),\n        \"target_uph_analyzed\": tool_output.get(\"target_uph\"), # Reference the target UPH used in the analysis\n        \"gap_uph\": tool_output.get(\"gap_uph\"),\n        \"is_target_achievable\": tool_output.get(\"is_target_achievable\"),\n        \"process_summary\": tool_output.get(\"process_summary\", []),\n        \"suggestions\": tool_output.get(\"suggestions\", [])\n    }\n    \n    updated_bop['_bottleneck_analysis_results'] = analysis_results\n\n    # CRITICAL â€” Parallel Instance Creation Rules:\n    # The Bottleneck Analyzer tool's output provides textual 'suggestions' for increasing\n    # parallel counts but does not return structured data (e.g., new 'process_details' entries\n    # with specific locations or resource assignments) that would allow this adapter to programmatically\n    # create new parallel instances in the BOP. Therefore, this function will not be creating\n    # new process_detail instances or modifying existing ones beyond adding the analysis results\n    # as a new top-level field.\n\n    return updated_bop\n",
  "model": "gemini-2.5-flash",
  "generated_at": "2026-02-15T14:37:12.472129"
}