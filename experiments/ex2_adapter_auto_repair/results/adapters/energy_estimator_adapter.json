{
  "tool_id": "energy_estimator",
  "pre_process_code": "import json\n\ndef convert_bop_to_input(bop_json: dict, params: dict) -> str:\n    tool_processes = []\n    tool_equipment_assignments = []\n\n    # --- 1. Prepare 'processes' for the tool input ---\n    # Group process_details by process_id to determine name, cycle_time, and parallel_count\n    process_details_map = {}\n    for pd in bop_json.get(\"process_details\", []):\n        pid = pd.get(\"process_id\")\n        if pid:\n            if pid not in process_details_map:\n                process_details_map[pid] = []\n            process_details_map[pid].append(pd)\n    \n    for pid, details_list in process_details_map.items():\n        # Take info from the first parallel instance for a given process_id\n        # Assuming name and cycle_time_sec are consistent across parallel instances of the same process_id\n        first_detail = details_list[0] if details_list else {}\n        name = first_detail.get(\"name\", pid) # Use process_id as fallback name\n        cycle_time_sec = first_detail.get(\"cycle_time_sec\", 0.0)\n        parallel_count = len(details_list) # Count of parallel instances for this process_id\n\n        tool_processes.append({\n            \"process_id\": pid,\n            \"name\": name,\n            \"cycle_time_sec\": cycle_time_sec,\n            \"parallel_count\": parallel_count\n        })\n\n    # --- 2. Prepare 'equipment_assignments' for the tool input ---\n    # Create a lookup for equipment details (name, type) by equipment_id\n    equipment_lookup = {eq.get(\"equipment_id\"): eq for eq in bop_json.get(\"equipments\", []) if eq.get(\"equipment_id\")}\n    \n    # Use a set to track unique (process_id, equipment_id) assignments to avoid duplicates,\n    # as the tool's 'equipment_assignments' seems to be per process_id, not per parallel_index.\n    assigned_equipment_set = set()\n\n    for ra in bop_json.get(\"resource_assignments\", []):\n        if ra.get(\"resource_type\") == \"equipment\":\n            process_id = ra.get(\"process_id\")\n            equipment_id = ra.get(\"resource_id\")\n            \n            if process_id and equipment_id and (process_id, equipment_id) not in assigned_equipment_set:\n                equipment_info = equipment_lookup.get(equipment_id)\n                if equipment_info:\n                    tool_equipment_assignments.append({\n                        \"process_id\": process_id,\n                        \"equipment_id\": equipment_id,\n                        \"equipment_name\": equipment_info.get(\"name\", equipment_id),\n                        \"equipment_type\": equipment_info.get(\"type\", \"default\") # Use 'default' if type is missing\n                    })\n                    assigned_equipment_set.add((process_id, equipment_id))\n\n    # --- 3. Prepare other parameters from the 'params' dict ---\n    # CRITICAL: Include ALL user parameters in the tool input JSON/CSV\n    energy_rates = params.get(\"energy_rates\")\n    production_volume = params.get(\"production_volume\", 1000)\n    cost_per_kwh = params.get(\"cost_per_kwh\", 0.12)\n\n    tool_input = {\n        \"processes\": tool_processes,\n        \"equipment_assignments\": tool_equipment_assignments,\n        \"energy_rates\": energy_rates,\n        \"production_volume\": production_volume,\n        \"cost_per_kwh\": cost_per_kwh\n    }\n\n    return json.dumps(tool_input, ensure_ascii=False)",
  "post_process_code": "def apply_result_to_bop(bop_json: dict, tool_output: dict) -> dict:\n    # CRITICAL: tool_output is ALREADY PARSED as dict by the executor\n    # DO NOT call json.loads(tool_output) - it will cause an error!\n\n    # The Energy Estimator tool output provides energy metrics per process,\n    # and overall totals. It does not modify existing BOP entities like location or size.\n    # The most appropriate way to integrate this data is to add a new top-level\n    # field to the BOP JSON to preserve all existing BOP fields not being updated.\n\n    # Extract relevant data from tool_output\n    process_energy_data = tool_output.get(\"process_energy\", [])\n    total_energy_kwh = tool_output.get(\"total_energy_kwh\", 0.0)\n    total_cost = tool_output.get(\"total_cost\", 0.0)\n    energy_by_type = tool_output.get(\"energy_by_type\", {})\n    production_volume = tool_output.get(\"production_volume\", 0) # Get effective volume from tool output\n    cost_per_kwh = tool_output.get(\"cost_per_kwh\", 0)       # Get effective cost rate from tool output\n    \n    # Store the results in a new top-level field in the BOP JSON\n    bop_json[\"computed_energy_analysis\"] = {\n        \"process_energy\": process_energy_data,\n        \"total_energy_kwh\": total_energy_kwh,\n        \"total_cost\": total_cost,\n        \"energy_by_type\": energy_by_type,\n        \"production_volume\": production_volume,\n        \"cost_per_kwh\": cost_per_kwh\n    }\n\n    return bop_json",
  "model": "gemini-2.5-flash",
  "generated_at": "2026-02-15T14:38:20.444576"
}