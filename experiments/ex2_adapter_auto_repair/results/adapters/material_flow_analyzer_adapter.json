{
  "tool_id": "material_flow_analyzer",
  "pre_process_code": "import json\n\ndef convert_bop_to_input(bop_json: dict, params: dict) -> str:\n    \"\"\"\n    Converts GDP BOP data to the Material Flow Analyzer tool's input format.\n\n    Args:\n        bop_json (dict): The BOP JSON data.\n        params (dict): User-configurable parameters from the UI.\n\n    Returns:\n        str: A JSON string formatted for the Material Flow Analyzer tool.\n    \"\"\"\n    tool_input = {}\n\n    # 1. Prepare 'processes' for the tool\n    # The tool's 'processes' require 'name', which comes from BOP's 'process_details'.\n    # Collect names, prioritizing parallel_index=1 or the first encountered for a process_id.\n    process_name_map = {}\n    for detail in bop_json.get('process_details', []):\n        pid = detail.get('process_id')\n        if pid and pid not in process_name_map:\n            process_name_map[pid] = detail.get('name', f\"Process {pid}\")\n\n    tool_processes = []\n    for p in bop_json.get('processes', []):\n        pid = p.get('process_id')\n        tool_processes.append({\n            \"process_id\": pid,\n            \"name\": process_name_map.get(pid, f\"Process {pid or 'Unknown'}\"), # Fallback for name if not found\n            \"predecessor_ids\": p.get('predecessor_ids', []),\n            \"successor_ids\": p.get('successor_ids', [])\n        })\n    tool_input['processes'] = tool_processes\n\n    # 2. Prepare 'material_assignments' for the tool\n    # This requires looking up material name and unit from the 'materials' list.\n    material_info_map = {}\n    for m in bop_json.get('materials', []):\n        mid = m.get('material_id')\n        if mid:\n            material_info_map[mid] = {\n                \"name\": m.get('name', mid), # Default to ID if name missing\n                \"unit\": m.get('unit', 'ea') # Default unit\n            }\n\n    tool_material_assignments = []\n    for ra in bop_json.get('resource_assignments', []):\n        if ra.get('resource_type') == 'material':\n            material_id = ra.get('resource_id')\n            if material_id:\n                material_info = material_info_map.get(material_id, {\"name\": material_id, \"unit\": \"unknown\"})\n                tool_material_assignments.append({\n                    \"process_id\": ra.get('process_id'),\n                    \"material_id\": material_id,\n                    \"material_name\": material_info['name'],\n                    \"quantity\": ra.get('quantity', 0.0),\n                    \"unit\": material_info['unit']\n                })\n    tool_input['material_assignments'] = tool_material_assignments\n\n    # CRITICAL: Include ALL user parameters (params) in the tool input.\n    # As per the instruction, these are added as top-level fields to the tool's input JSON.\n    # The Material Flow Analyzer tool's core logic does not explicitly read these,\n    # but they are included as per the prompt's general requirement for user parameters.\n    for key, value in params.items():\n        if key not in tool_input: # Ensure we don't overwrite required tool inputs like 'processes'\n            tool_input[key] = value\n\n    return json.dumps(tool_input, ensure_ascii=False)\n",
  "post_process_code": "import json\n\ndef apply_result_to_bop(bop_json: dict, tool_output: dict) -> dict:\n    \"\"\"\n    Applies the Material Flow Analyzer tool's output back to the BOP data.\n\n    Args:\n        bop_json (dict): The original BOP JSON data.\n        tool_output (dict): The parsed JSON output from the Material Flow Analyzer tool.\n\n    Returns:\n        dict: The updated BOP JSON data.\n    \"\"\"\n    # The Material Flow Analyzer tool's output contains 'material_flows', 'flow_paths', and 'summary'.\n    # These results do not directly modify existing structural elements in the BOP schema.\n    # Following the pattern of adding new analysis results, these will be added as\n    # new top-level fields to the BOP JSON. This preserves all existing BOP fields.\n\n    # Add the analysis results directly to the the top-level of the BOP JSON.\n    # Use .get() with empty defaults to handle cases where the tool might not return\n    # all expected fields (e.g., in case of an internal tool error).\n    bop_json['material_flows'] = tool_output.get('material_flows', [])\n    bop_json['flow_paths'] = tool_output.get('flow_paths', [])\n    bop_json['summary'] = tool_output.get('summary', {})\n\n    # If the tool explicitly returned an error message, include it in the BOP.\n    if 'error' in tool_output:\n        bop_json['tool_error_material_flow_analyzer'] = tool_output['error']\n\n    return bop_json\n",
  "model": "gemini-2.5-flash",
  "generated_at": "2026-02-15T14:47:41.097761"
}